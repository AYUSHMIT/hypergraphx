
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>hnx.communities.hypergraph_mt.model &#8212; HNX 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for hnx.communities.hypergraph_mt.model</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">comb</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">root</span>

<span class="kn">from</span> <span class="nn">hnx.core.hypergraph</span> <span class="kn">import</span> <span class="n">Hypergraph</span>
<span class="kn">from</span> <span class="nn">hnx.linalg.linalg</span> <span class="kn">import</span> <span class="n">binary_incidence_matrix</span><span class="p">,</span> <span class="n">incidence_matrix</span>
<span class="kn">from</span> <span class="nn">hnx.communities.hy_sc.model</span> <span class="kn">import</span> <span class="n">HySC</span>

<span class="n">DEFAULT_SEED</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">DEFAULT_INF</span> <span class="o">=</span> <span class="mf">1e10</span>  <span class="c1"># infinite initial value for the log-likelihood</span>
<span class="n">DEFAULT_EPS</span> <span class="o">=</span> <span class="mf">1e-20</span>  <span class="c1"># epsilon for numerical stability</span>


<div class="viewcode-block" id="HypergraphMT"><a class="viewcode-back" href="../../../../hnx.communities.hypergraph_mt.html#hnx.communities.hypergraph_mt.model.HypergraphMT">[docs]</a><span class="k">class</span> <span class="nc">HypergraphMT</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Implementation of the Hypergraph-MT probabilistic model from</span>

<span class="sd">    &quot;Inference of hyperedges and overlapping communities in hypergraphs&quot;,</span>
<span class="sd">    Contisciani M., Battiston F., De Bacco C.</span>

<span class="sd">    The probabilistic generative model infers overlapping communities in hypergraphs.</span>
<span class="sd">    It is a mixed-membership model where we assume an assortative structure. The inference is performed</span>
<span class="sd">    using an efficient expectation-maximization (EM) algorithm that exploits the sparsity of the network,</span>
<span class="sd">    leading to an efficient and scalable implementation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">noise_input_par</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
        <span class="n">min_value_par</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span>
        <span class="n">max_value_par</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e2</span><span class="p">,</span>
        <span class="n">n_realizations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
        <span class="n">max_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
        <span class="n">check_convergence_every</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">threshold_for_convergence</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initialize the probabilistic model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        noise_input_par: noise to initialize the membership matrix u or the affinity matrix w around input values.</span>
<span class="sd">        min_value_par: minimum value for the parameters.</span>
<span class="sd">        max_value_par: minimum value for the parameters.</span>
<span class="sd">        n_realizations: number of realizations with different random initialization.</span>
<span class="sd">        max_iter: maximum number of EM iteration steps before aborting.</span>
<span class="sd">        check_convergence_every: number of steps in between every convergence check.</span>
<span class="sd">        tolerance: tolerance parameter for convergence of the log-likelihood.</span>
<span class="sd">        threshold_for_convergence: number of consecutive convergences for the EM to stop.</span>
<span class="sd">        verbose: flag to print details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Parameters related attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noise_input_par</span> <span class="o">=</span> <span class="n">noise_input_par</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_value_par</span> <span class="o">=</span> <span class="n">min_value_par</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_value_par</span> <span class="o">=</span> <span class="n">max_value_par</span>
        <span class="c1"># Training related attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_realizations</span> <span class="o">=</span> <span class="n">n_realizations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_convergence_every</span> <span class="o">=</span> <span class="n">check_convergence_every</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold_for_convergence</span> <span class="o">=</span> <span class="n">threshold_for_convergence</span>
        <span class="c1"># Attribute to print details.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="c1"># Initial value for the maximum log-likelihood.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxL</span> <span class="o">=</span> <span class="o">-</span><span class="n">DEFAULT_INF</span>
        <span class="c1"># DataFrame to keep track of training information.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_info</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

<div class="viewcode-block" id="HypergraphMT.fit"><a class="viewcode-back" href="../../../../hnx.communities.hypergraph_mt.html#hnx.communities.hypergraph_mt.model.HypergraphMT.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hypergraph</span><span class="p">:</span> <span class="n">Hypergraph</span><span class="p">,</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">normalizeU</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">extra_params</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Perform community detection on hypergraphs with a mixed-membership probabilistic model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hypergraph: the hypergraph to perform inference on.</span>
<span class="sd">        K: number of communities.</span>
<span class="sd">        seed: random seed.</span>
<span class="sd">        normalizeU: if True, then the membership matrix u is normalized such that every row sums to 1.</span>
<span class="sd">        **extra_params: additional keyword arguments handed to __check_fit_params to handle u and w.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        u_f: membership matrix of dimension (N, K).</span>
<span class="sd">        w_f: affinity matrix of dimension (D-1, K).</span>
<span class="sd">        maxL: maximum log-likelihood value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize all the values needed for training.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_fit_params</span><span class="p">(</span>
            <span class="n">hypergraph</span><span class="o">=</span><span class="n">hypergraph</span><span class="p">,</span>
            <span class="n">K</span><span class="o">=</span><span class="n">K</span><span class="p">,</span>
            <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
            <span class="n">normalizeU</span><span class="o">=</span><span class="n">normalizeU</span><span class="p">,</span>
            <span class="o">**</span><span class="n">extra_params</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Keep track of log-likelihood values, running time, and other training info.</span>
        <span class="n">train_info</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">final_it</span><span class="p">,</span> <span class="n">final_convergence</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_realizations</span><span class="p">):</span>
            <span class="c1"># Initialize psiOmega and psiBarOmega.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_psiOmega</span><span class="p">()</span>

            <span class="c1"># Initialize the membership matrix u and the affinity matrix w.</span>
            <span class="c1"># For the first iteration, we initialize u around the solution of the Hypergraph Spectral Clustering.</span>
            <span class="c1"># For the next ones, we initialize the parameters either randomly or</span>
            <span class="c1"># around the input values chosen with &quot;initialize_u0&quot;.</span>
            <span class="c1"># In the end, we choose the realization with the best likelihood.</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_u_w</span><span class="p">(</span><span class="n">hyperEdges</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hyperEdges</span><span class="p">,</span> <span class="n">baseline_HySC</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_u_w</span><span class="p">(</span><span class="n">hyperEdges</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hyperEdges</span><span class="p">,</span> <span class="n">baseline_HySC</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># First update of the matrices u, psiOmega and psiBarOmega.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initial_update_u_psi</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">)</span>
            <span class="c1"># Initialize the rho matrix that represents the variational distribution used in the EM routine.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_rho</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Updating realization </span><span class="si">{</span><span class="n">r</span><span class="si">}</span><span class="s2"> ...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Initial value for the log-likelihood.</span>
            <span class="n">loglik</span> <span class="o">=</span> <span class="o">-</span><span class="n">DEFAULT_INF</span>
            <span class="c1"># Convergence local variables.</span>
            <span class="n">n_tolerance_reached</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">0</span>  <span class="c1"># number of consecutive times the tolerance is reached</span>
            <span class="p">)</span>
            <span class="n">converged</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># flag for reached convergence</span>
            <span class="n">it</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># iteration</span>

            <span class="c1"># EM routine.</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">converged</span> <span class="ow">and</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">:</span>
                <span class="n">time_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="c1"># Train.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_em</span><span class="p">()</span>

                <span class="c1"># Check for convergence.</span>
                <span class="n">loglik</span><span class="p">,</span> <span class="n">n_tolerance_reached</span><span class="p">,</span> <span class="n">converged</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_for_convergence</span><span class="p">(</span>
                    <span class="n">it</span><span class="p">,</span> <span class="n">loglik</span><span class="p">,</span> <span class="n">n_tolerance_reached</span><span class="p">,</span> <span class="n">converged</span>
                <span class="p">)</span>
                <span class="c1"># Store training information.</span>
                <span class="n">runtime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">time_start</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">it</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_convergence_every</span><span class="p">:</span>
                    <span class="n">train_info</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span> <span class="n">loglik</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">converged</span><span class="p">))</span>
                <span class="n">it</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;N_real=</span><span class="si">{</span><span class="n">r</span><span class="si">}</span><span class="s2"> -- num it=</span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s2"> -- Loglikelihood:</span><span class="si">{</span><span class="n">loglik</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Save parameters for the realization with the highest log-likelihood.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxL</span> <span class="o">&lt;</span> <span class="n">loglik</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_optimal_parameters</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">maxL</span> <span class="o">=</span> <span class="n">loglik</span>
                <span class="n">final_it</span> <span class="o">=</span> <span class="n">it</span>
                <span class="n">final_convergence</span> <span class="o">=</span> <span class="n">converged</span>

            <span class="c1"># Update seed.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">prng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1e6</span><span class="p">))</span>
        <span class="c1"># end cycle over realizations</span>

        <span class="c1"># Update DataFrame with training information.</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;realization&quot;</span><span class="p">,</span>
            <span class="s2">&quot;seed&quot;</span><span class="p">,</span>
            <span class="s2">&quot;iter&quot;</span><span class="p">,</span>
            <span class="s2">&quot;loglik&quot;</span><span class="p">,</span>
            <span class="s2">&quot;runtime&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reached_convergence&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_info</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">train_info</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>

        <span class="c1"># Convergence not reached.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">final_it</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span> <span class="ow">not</span> <span class="n">final_convergence</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Solution failed to converge in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="si">}</span><span class="s2"> EM steps!&quot;</span><span class="p">)</span>

        <span class="c1"># Save inferred parameters.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_inference</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_output_results</span><span class="p">(</span><span class="n">final_it</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxL</span></div>

    <span class="k">def</span> <span class="nf">_check_fit_params</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hypergraph</span><span class="p">:</span> <span class="n">Hypergraph</span><span class="p">,</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">normalizeU</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">extra_params</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Pre-process the data and initialize parameters for the inference.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hypergraph: the hypergraph to perform inference on.</span>
<span class="sd">        K: number of communities.</span>
<span class="sd">        seed: random seed.</span>
<span class="sd">        normalizeU: if True, then the membership matrix u is normalized such that every row sums to 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Save hypergraph.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hypergraph</span> <span class="o">=</span> <span class="n">hypergraph</span>

        <span class="c1"># Set the pseudo-random number generator.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="c1"># Weights of hyperedges.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hye_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hypergraph</span><span class="o">.</span><span class="n">get_weights</span><span class="p">())</span>
        <span class="c1"># Hyperedges list.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hyperEdges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hypergraph</span><span class="o">.</span><span class="n">get_edges</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="c1"># Weighted incidence matrix.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">incidence</span> <span class="o">=</span> <span class="n">incidence_matrix</span><span class="p">(</span><span class="n">hypergraph</span><span class="p">)</span>
        <span class="c1"># Binary incidence matrix.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binary_incidence</span> <span class="o">=</span> <span class="n">binary_incidence_matrix</span><span class="p">(</span><span class="n">hypergraph</span><span class="p">)</span>

        <span class="c1"># Number of nodes, and number of hyperedges.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">incidence</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1"># Number of communities.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="n">K</span>
        <span class="c1"># Maximum observed hyperedge size.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hyperEdges</span><span class="p">])</span>

        <span class="c1"># List of length N containing the indices of non-zero hyperedges for every node.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hye_per_node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">incidence</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">incidence</span><span class="o">.</span><span class="n">indptr</span><span class="p">)[</span>
            <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span>
        <span class="p">]</span>  <span class="c1"># TODO: implement it as a core method</span>
        <span class="c1"># List of list containing the indices of hyperedges with a given degree.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">HyD2eId</span> <span class="o">=</span> <span class="n">extract_indicesHy</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hyperEdges</span>
        <span class="p">)</span>  <span class="c1"># TODO: implement it as a core method</span>
        <span class="c1"># Hyperedges&#39; size.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">HyeId2D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">hypergraph</span><span class="o">.</span><span class="n">get_sizes</span><span class="p">()</span>
        <span class="p">)</span>  <span class="c1"># TODO: check whether we want to refactor the name of this variable</span>

        <span class="c1"># Isolated nodes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isolates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">incidence</span><span class="o">.</span><span class="n">getnnz</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span>
            <span class="mi">0</span>
        <span class="p">]</span>  <span class="c1"># TODO: implement it as a core method</span>
        <span class="c1"># Non-isolated nodes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_isolates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">incidence</span><span class="o">.</span><span class="n">getnnz</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span>
            <span class="mi">0</span>
        <span class="p">]</span>  <span class="c1"># TODO: implement it as a core method</span>

        <span class="c1"># Normalize u such that every row sums to 1.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalizeU</span> <span class="o">=</span> <span class="n">normalizeU</span>

        <span class="n">available_extra_params</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;fix_communities&quot;</span><span class="p">,</span>  <span class="c1"># flag to keep the communities fixed</span>
            <span class="s2">&quot;fix_w&quot;</span><span class="p">,</span>  <span class="c1"># flag to keep the affinity matrix fixed</span>
            <span class="s2">&quot;gammaU&quot;</span><span class="p">,</span>  <span class="c1"># constant to regularize the communities</span>
            <span class="s2">&quot;gammaW&quot;</span><span class="p">,</span>  <span class="c1"># constant to regularize the affinity matrix</span>
            <span class="c1"># initialize u with input array, stored file, or the solution of the Hypergraph Spectral Clustering</span>
            <span class="s2">&quot;initialize_u0&quot;</span><span class="p">,</span>
            <span class="s2">&quot;initialize_w0&quot;</span><span class="p">,</span>  <span class="c1"># initialize w with input array or from a stored file</span>
            <span class="s2">&quot;out_inference&quot;</span><span class="p">,</span>  <span class="c1"># flag to store the inferred parameters</span>
            <span class="s2">&quot;out_folder&quot;</span><span class="p">,</span>  <span class="c1"># path to store the output</span>
            <span class="s2">&quot;end_file&quot;</span><span class="p">,</span>  <span class="c1"># output file suffix</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">extra_param</span> <span class="ow">in</span> <span class="n">extra_params</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">extra_param</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">available_extra_params</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Ignoring unrecognised parameter </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">extra_param</span>
                <span class="k">raise</span> <span class="ne">Warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;fix_communities&quot;</span> <span class="ow">in</span> <span class="n">extra_params</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fix_communities</span> <span class="o">=</span> <span class="n">extra_params</span><span class="p">[</span><span class="s2">&quot;fix_communities&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fix_communities</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="s2">&quot;fix_w&quot;</span> <span class="ow">in</span> <span class="n">extra_params</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fix_w</span> <span class="o">=</span> <span class="n">extra_params</span><span class="p">[</span><span class="s2">&quot;fix_w&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fix_w</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="s2">&quot;gammaU&quot;</span> <span class="ow">in</span> <span class="n">extra_params</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gammaU</span> <span class="o">=</span> <span class="n">extra_params</span><span class="p">[</span><span class="s2">&quot;gammaU&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gammaU</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="s2">&quot;gammaW&quot;</span> <span class="ow">in</span> <span class="n">extra_params</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gammaW</span> <span class="o">=</span> <span class="n">extra_params</span><span class="p">[</span><span class="s2">&quot;gammaW&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gammaW</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">u0</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;initialize_u0&quot;</span> <span class="ow">in</span> <span class="n">extra_params</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">extra_params</span><span class="p">[</span><span class="s2">&quot;initialize_u0&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">u0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_u0</span><span class="p">(</span><span class="n">extra_params</span><span class="p">[</span><span class="s2">&quot;initialize_u0&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u0</span> <span class="o">=</span> <span class="n">u0</span>

        <span class="n">w0</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;initialize_w0&quot;</span> <span class="ow">in</span> <span class="n">extra_params</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">extra_params</span><span class="p">[</span><span class="s2">&quot;initialize_w0&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">w0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_w0</span><span class="p">(</span><span class="n">extra_params</span><span class="p">[</span><span class="s2">&quot;initialize_w0&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w0</span> <span class="o">=</span> <span class="n">w0</span>

        <span class="k">if</span> <span class="s2">&quot;out_inference&quot;</span> <span class="ow">in</span> <span class="n">extra_params</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">out_inference</span> <span class="o">=</span> <span class="n">extra_params</span><span class="p">[</span><span class="s2">&quot;out_inference&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">out_inference</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="s2">&quot;out_folder&quot;</span> <span class="ow">in</span> <span class="n">extra_params</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">out_folder</span> <span class="o">=</span> <span class="n">extra_params</span><span class="p">[</span><span class="s2">&quot;out_folder&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">out_folder</span> <span class="o">=</span> <span class="s2">&quot;../data/output/&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;end_file&quot;</span> <span class="ow">in</span> <span class="n">extra_params</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">end_file</span> <span class="o">=</span> <span class="n">extra_params</span><span class="p">[</span><span class="s2">&quot;end_file&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">end_file</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_set_seed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set the container for the Mersenne Twister pseudo-random number generator.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="n">DEFAULT_SEED</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_u0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initialize u with input array, stored file, or the solution of the Hypergraph Spectral Clustering.&quot;&quot;&quot;</span>
        <span class="c1"># Initialize u with input array.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_val</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">input_val</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
                <span class="n">u0</span> <span class="o">=</span> <span class="n">u0_w0_from_nparray</span><span class="p">(</span><span class="n">input_val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;u0 must have shape </span><span class="si">{</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span><span class="si">}</span><span class="s2">. In input was given </span><span class="si">{</span><span class="n">input_val</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">!&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># Initialize u either with the solution of the Hypergraph Spectral Clustering or from a stored file.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">input_val</span> <span class="o">==</span> <span class="s2">&quot;spectral&quot;</span><span class="p">:</span>
                <span class="n">u0</span> <span class="o">=</span> <span class="n">calculate_u_HySC</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hypergraph</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">input_val</span><span class="p">):</span>
                    <span class="n">u0</span> <span class="o">=</span> <span class="n">u0_w0_from_file</span><span class="p">(</span><span class="n">input_val</span><span class="p">,</span> <span class="n">par</span><span class="o">=</span><span class="s2">&quot;u&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">input_val</span><span class="si">}</span><span class="s2"> does not exist!&quot;</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">u0</span>

    <span class="k">def</span> <span class="nf">_initialize_w0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initialize w with input array or from a stored file.&quot;&quot;&quot;</span>
        <span class="c1"># Initialize w with input array.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_val</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">input_val</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
                <span class="n">w0</span> <span class="o">=</span> <span class="n">u0_w0_from_nparray</span><span class="p">(</span><span class="n">input_val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;w0 must have shape </span><span class="si">{</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span><span class="si">}</span><span class="s2">. In input was given </span><span class="si">{</span><span class="n">input_val</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">!&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># Initialize w from a stored file.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">input_val</span><span class="p">):</span>
                <span class="n">w0</span> <span class="o">=</span> <span class="n">u0_w0_from_file</span><span class="p">(</span><span class="n">input_val</span><span class="p">,</span> <span class="n">par</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">input_val</span><span class="si">}</span><span class="s2"> does not exist!&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">w0</span>

    <span class="k">def</span> <span class="nf">_initialize_psiOmega</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initialize psi matrices psiOmega and psiBarOmega, i.e., psi(0)(Omega^d, k) and psi(0)(BarOmega^d, k).</span>
<span class="sd">        They have dimension DxK, and the first row refers to degree=1. See the Supplementary Note 1 for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psiBarOmega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_dummy_u0</span><span class="p">()</span>
        <span class="n">u0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u0_dummy</span><span class="p">)</span>
        <span class="n">u0_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u0_dummy</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">non_isolates</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
            <span class="n">Nk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">u0</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">u0</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">u0_mean</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">Nk</span><span class="p">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_dummy_u0</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initial dummy u0 to compute psiOmega in closed-form at step t==0.&quot;&quot;&quot;</span>
        <span class="n">uk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prng</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u0_dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">uk</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="n">row_sums</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u0_dummy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u0_dummy</span><span class="p">[</span><span class="n">row_sums</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">row_sums</span><span class="p">[</span><span class="n">row_sums</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_initialize_u_w</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hyperEdges</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">baseline_HySC</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initialization of the parameters u and w.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hyperEdges : array of length E, containing the sets of hyper-edges (as tuples).</span>
<span class="sd">        baseline_HySC : flag to initialize u around the solution of the Hypergraph Spectral Clustering.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize u around the solution of the Hypergraph Spectral Clustering.</span>
        <span class="k">if</span> <span class="n">baseline_HySC</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;u is initialized around the solution of the Hypergraph Spectral Clustering.&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u0_current_real_t0</span> <span class="o">=</span> <span class="n">calculate_u_HySC</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hypergraph</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span>
            <span class="p">)</span>
            <span class="n">max_entry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u0_current_real_t0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u0_current_real_t0</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">max_entry</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_input_par</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prng</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u0_current_real_t0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># Initialize u either randomly or around the input values chosen with &quot;initialize_u0&quot;.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">u0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;u is initialized randomly.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u0_current_real_t0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_randomize_u0</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;u is initialized around the input values chosen with &#39;initialize_u0&#39;.&quot;</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u0_current_real_t0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_noise_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u0</span><span class="p">)</span>
        <span class="c1"># Initialize w either randomly or around the input values chosen with &quot;initialize_w0&quot;.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">w0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w is initialized randomly.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_randomize_w0</span><span class="p">(</span><span class="n">hyperEdges</span><span class="o">=</span><span class="n">hyperEdges</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;w is initialized around the input values chosen with &#39;initialize_w0&#39;.&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_noise_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w_old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_randomize_u0</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initialize membership matrix u randomly.&quot;&quot;&quot;</span>
        <span class="n">u0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prng</span><span class="o">.</span><span class="n">random_sample</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">))</span>
        <span class="n">row_sums</span> <span class="o">=</span> <span class="n">u0</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">u0</span><span class="p">[</span><span class="n">row_sums</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">row_sums</span><span class="p">[</span><span class="n">row_sums</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">u0</span>

    <span class="k">def</span> <span class="nf">_randomize_w0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hyperEdges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initialize affinity matrix w randomly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hyperEdges: array of length E, containing the sets of hyper-edges (as tuples).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        w0: initial affinity matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">w0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prng</span><span class="o">.</span><span class="n">random_sample</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">hyperEdges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="nb">list</span><span class="p">(</span>
                    <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span>
                        <span class="nb">set</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">hyperEdges</span><span class="p">])</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;setting certain d in w to zero:&quot;</span><span class="p">,</span> <span class="n">ds</span><span class="p">)</span>
                <span class="n">w0</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="n">w0</span>

    <span class="k">def</span> <span class="nf">_add_noise_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">par0</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add noise to input values.&quot;&quot;&quot;</span>
        <span class="n">max_entry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">par0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">par0</span> <span class="o">+</span> <span class="n">max_entry</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_input_par</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prng</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span>
            <span class="n">par0</span><span class="o">.</span><span class="n">shape</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initial_update_u_psi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;First update of the matrices u, psiOmega and psiBarOmega.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u0_dummy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u0_dummy</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_psiBarOmega</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">isolates</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u0_current_real_t0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">low_values_indices</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_value_par</span>
                <span class="p">)</span>  <span class="c1"># values are too low</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">low_values_indices</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># and set to 0.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_update_psiOmega</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">u_old</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_update_psiBarOmega</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ks</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Update psiBarOmega matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i: row index.</span>
<span class="sd">        ks: column index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        success: flag to check whether the matrix psiBarOmega has all non-negative entries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">ks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">psiBarOmega</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">psiBarOmega</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiBarOmega</span><span class="p">[</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">psiBarOmega</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ks</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ks</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ks</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">psiBarOmega</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">ks</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">ks</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ks</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiBarOmega</span><span class="p">[</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">ks</span><span class="p">]</span>
                <span class="p">)</span>

        <span class="n">tmpMask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiBarOmega</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tmpMask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psiBarOmega</span><span class="p">[</span><span class="n">tmpMask</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">1e-3</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">psiBarOmega</span><span class="p">[</span><span class="n">tmpMask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psiBarOmega</span><span class="p">[</span><span class="n">tmpMask</span><span class="p">])</span>
        <span class="n">tmpMask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiBarOmega</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tmpMask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">success</span>

    <span class="k">def</span> <span class="nf">_update_psiOmega</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ks</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Update psiOmega matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i: row index.</span>
<span class="sd">        r: number of realization.</span>
<span class="sd">        ks: column index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_old</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                    <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_old</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiBarOmega</span><span class="p">[</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ks</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ks</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ks</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_old</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ks</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">ks</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">ks</span><span class="p">]</span>
                    <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ks</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_old</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ks</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiBarOmega</span><span class="p">[</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">ks</span><span class="p">]</span>
                <span class="p">)</span>

        <span class="n">tmpMask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tmpMask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">tmpMask</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">1e-3</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">tmpMask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">tmpMask</span><span class="p">])</span>

        <span class="c1"># Perform a check.</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">tmpMask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span> <span class="o">&lt;</span> <span class="mi">0</span>
                <span class="n">tmpMask2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">tmpMask</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-3</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="n">tmpMask2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="n">tmpMask2</span><span class="p">])</span>
                <span class="n">tmpMask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span> <span class="o">&lt;</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">tmpMask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;psiOmega&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="n">tmpMask</span><span class="p">])</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tmpMask</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;i=&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hye_per_node</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_update_rho</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Update the rho matrix that represents the variational distribution used in the EM routine.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">HyeId2D</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">binary_incidence</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">+</span> <span class="n">DEFAULT_EPS</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">row_sums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">[</span><span class="n">row_sums</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">row_sums</span><span class="p">[</span><span class="n">row_sums</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_update_em</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Expectation-Maximization routine.</span>
<span class="sd">        If the parameters are considered fixed, they will not be updated when calling the .fit method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fix_w</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_w</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_rho</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fix_communities</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_u</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_rho</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_update_w</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Update affinity matrix w.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
                <span class="s2">&quot;I,Ik-&gt;k&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hye_weights</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">HyD2eId</span><span class="p">[</span><span class="n">d</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">HyD2eId</span><span class="p">[</span><span class="n">d</span><span class="p">]]</span>
            <span class="p">)</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gammaW</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">non_zeros</span> <span class="o">=</span> <span class="n">Z</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">non_zeros</span><span class="p">]</span> <span class="o">/=</span> <span class="n">Z</span><span class="p">[</span><span class="n">non_zeros</span><span class="p">]</span>
        <span class="c1"># dist_w = np.amax(abs(self.w - self.w_old))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w_old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_u</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Update membership matrix u. It is parallel for all the k of a node, but sequential in nodes (with random</span>
<span class="sd">        permutation of the nodes).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prng</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">perm</span><span class="p">:</span>
            <span class="n">ks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_value_par</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">success</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_psiBarOmega</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ks</span><span class="o">=</span><span class="n">ks</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
                    <span class="n">u_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
                        <span class="s2">&quot;I,Ik-&gt;k&quot;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">incidence</span><span class="p">[[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">hye_per_node</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">hye_per_node</span><span class="p">[</span><span class="n">i</span><span class="p">]][:,</span> <span class="n">ks</span><span class="p">],</span>
                    <span class="p">)</span>
                    <span class="n">u_tmp_den</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gammaU</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">[:,</span> <span class="n">ks</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiBarOmega</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ks</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                    <span class="p">)</span>  <span class="c1"># sum over d</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalizeU</span><span class="p">:</span>
                        <span class="n">low_values_indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_tmp</span> <span class="o">/</span> <span class="n">u_tmp_den</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_value_par</span>
                        <span class="n">u_tmp</span><span class="p">[</span><span class="n">low_values_indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                        <span class="n">lambda_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enforce_constraint_u</span><span class="p">(</span><span class="n">u_tmp</span><span class="p">,</span> <span class="n">u_tmp_den</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ks</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_tmp</span> <span class="o">/</span> <span class="p">(</span><span class="n">lambda_i</span> <span class="o">+</span> <span class="n">u_tmp_den</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ks</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_tmp</span> <span class="o">/</span> <span class="n">u_tmp_den</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">check_u</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ks</span><span class="p">)</span>

                    <span class="n">low_values_indices</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_value_par</span>
                    <span class="p">)</span>  <span class="c1"># values are too low</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">low_values_indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># and set to 0.</span>

                    <span class="n">high_values_indices</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_value_par</span>
                    <span class="p">)</span>  <span class="c1"># values are too high</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">high_values_indices</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e2</span>  <span class="c1"># and set to 100.</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_update_psiOmega</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">ks</span><span class="o">=</span><span class="n">ks</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u_old</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="c1"># dist_u = np.amax(abs(self.u - self.u_old))</span>

<div class="viewcode-block" id="HypergraphMT.enforce_constraint_u"><a class="viewcode-back" href="../../../../hnx.communities.hypergraph_mt.html#hnx.communities.hypergraph_mt.model.HypergraphMT.enforce_constraint_u">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">enforce_constraint_u</span><span class="p">(</span><span class="n">num</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">den</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the lagrangian multiplier to enforce the constraint on the matrix u.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        num: numerator of the update of the membership matrix u.</span>
<span class="sd">        den: denominator of the update of the membership matrix u.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lambda_i: lagrangian multiplier.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lambda_i_test</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span>
            <span class="n">func_lagrange_multiplier</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">]),</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">den</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">lambda_i</span> <span class="o">=</span> <span class="n">lambda_i_test</span><span class="o">.</span><span class="n">x</span>
        <span class="k">return</span> <span class="n">lambda_i</span></div>

<div class="viewcode-block" id="HypergraphMT.check_u"><a class="viewcode-back" href="../../../../hnx.communities.hypergraph_mt.html#hnx.communities.hypergraph_mt.model.HypergraphMT.check_u">[docs]</a>    <span class="k">def</span> <span class="nf">check_u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ks</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Check the updated value of u[i].&quot;&quot;&quot;</span>
        <span class="n">tmpMask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ks</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tmpMask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ks</span><span class="p">][</span><span class="n">tmpMask</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">1e-01</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ks</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ks</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Warning</span><span class="p">(</span><span class="s2">&quot;WARNING!&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">_check_for_convergence</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">loglik</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">n_tolerance_reached</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">converged</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Check for convergence by using the log-likelihood.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        it: iteration.</span>
<span class="sd">        loglik: log-likelihood value.</span>
<span class="sd">        n_tolerance_reached: number of time the update of the log-likelihood respects the tolerance.</span>
<span class="sd">        converged: flag for reached convergence.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglik: log-likelihood value.</span>
<span class="sd">        n_tolerance_reached: number of time the update of the log-likelihood respects the tolerance.</span>
<span class="sd">        converged: flag for reached convergence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">it</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_convergence_every</span><span class="p">:</span>
            <span class="n">old_L</span> <span class="o">=</span> <span class="n">loglik</span>
            <span class="n">loglik</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_LogLikelihood</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">loglik</span> <span class="o">-</span> <span class="n">old_L</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">:</span>
                <span class="n">n_tolerance_reached</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_tolerance_reached</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">n_tolerance_reached</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold_for_convergence</span><span class="p">:</span>
            <span class="n">converged</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">loglik</span><span class="p">,</span> <span class="n">n_tolerance_reached</span><span class="p">,</span> <span class="n">converged</span>

    <span class="k">def</span> <span class="nf">_LogLikelihood</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">EPS</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mf">1e-300</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Compute the log-likelihood of the data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        EPS: random noise.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglik: log-likelihood value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Priors.</span>
        <span class="n">loglik</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">gammaW</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">gammaU</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">)</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">HyeId2D</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">binary_incidence</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">+</span> <span class="n">DEFAULT_EPS</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">loglik</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hye_weights</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">EPS</span><span class="p">))</span>

        <span class="n">loglik</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">psiOmega</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">)]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">loglik</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Log-likelihood is NaN!!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">DEFAULT_INF</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">loglik</span>

    <span class="k">def</span> <span class="nf">_update_optimal_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Update values of the parameters after convergence.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_output_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it_of_convergence</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Save the results in a .npz file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        it_of_convergence: iteration of convergence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: check if we should add this function somewhere else, i.e., in the readwrite.</span>
        <span class="n">outfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_folder</span> <span class="o">+</span> <span class="s2">&quot;theta&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_file</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span>
            <span class="n">outfile</span> <span class="o">+</span> <span class="s2">&quot;.npz&quot;</span><span class="p">,</span>
            <span class="n">u</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">u_f</span><span class="p">,</span>
            <span class="n">w</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">w_f</span><span class="p">,</span>
            <span class="n">final_it</span><span class="o">=</span><span class="n">it_of_convergence</span><span class="p">,</span>
            <span class="n">maxL</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">maxL</span><span class="p">,</span>
            <span class="n">non_isolates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">non_isolates</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Inferred parameters saved in: </span><span class="si">{</span><span class="n">outfile</span> <span class="o">+</span> <span class="s2">&quot;.npz&quot;</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;To load: theta=np.load(filename), then e.g. theta[&quot;u&quot;]&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="extract_indicesHy"><a class="viewcode-back" href="../../../../hnx.communities.hypergraph_mt.html#hnx.communities.hypergraph_mt.model.extract_indicesHy">[docs]</a><span class="k">def</span> <span class="nf">extract_indicesHy</span><span class="p">(</span><span class="n">hyperEdges</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Lists containing information about the hyperedges.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hyperEdges: array of length E, containing the sets of hyperedges (as tuples).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    HyD2eId: list of list containing the indices of hyperedges with a given degree.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">HyeId2D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">hyperEdges</span><span class="p">])</span>
    <span class="n">HyD2eId</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">HyeId2D</span> <span class="o">==</span> <span class="n">d</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">HyeId2D</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">HyD2eId</span></div>


<div class="viewcode-block" id="u0_w0_from_nparray"><a class="viewcode-back" href="../../../../hnx.communities.hypergraph_mt.html#hnx.communities.hypergraph_mt.model.u0_w0_from_nparray">[docs]</a><span class="k">def</span> <span class="nf">u0_w0_from_nparray</span><span class="p">(</span><span class="n">input_array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Import an array.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">input_array</span></div>


<div class="viewcode-block" id="u0_w0_from_file"><a class="viewcode-back" href="../../../../hnx.communities.hypergraph_mt.html#hnx.communities.hypergraph_mt.model.u0_w0_from_file">[docs]</a><span class="k">def</span> <span class="nf">u0_w0_from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">par</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Load an array from a .npz file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename: path of the stored file.</span>
<span class="sd">    par: name of the parameter to import.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Array to use as initialization for the given parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">theta</span><span class="p">[</span><span class="n">par</span><span class="p">]</span></div>


<div class="viewcode-block" id="calculate_u_HySC"><a class="viewcode-back" href="../../../../hnx.communities.hypergraph_mt.html#hnx.communities.hypergraph_mt.model.calculate_u_HySC">[docs]</a><span class="k">def</span> <span class="nf">calculate_u_HySC</span><span class="p">(</span><span class="n">hypergraph</span><span class="p">:</span> <span class="n">Hypergraph</span><span class="p">,</span> <span class="n">K</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Calculate the memberships with the Hypergraph Spectral Clustering.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hypergraph: the hypergraph to perform inference on.</span>
<span class="sd">    K:number of communities.</span>
<span class="sd">    seed: random seed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Membership matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sc_model</span> <span class="o">=</span> <span class="n">HySC</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sc_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">hypergraph</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="n">K</span><span class="p">)</span></div>


<div class="viewcode-block" id="func_lagrange_multiplier"><a class="viewcode-back" href="../../../../hnx.communities.hypergraph_mt.html#hnx.communities.hypergraph_mt.model.func_lagrange_multiplier">[docs]</a><span class="k">def</span> <span class="nf">func_lagrange_multiplier</span><span class="p">(</span><span class="n">lambda_i</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">den</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the objective function to find the lagrangian multiplier to enforce the constraint on the matrix u.&quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="p">(</span><span class="n">lambda_i</span> <span class="o">+</span> <span class="n">den</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">HNX</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules.html">hnx</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, HNX's authors.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.4.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>